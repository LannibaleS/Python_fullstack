l1 = [1,2,3,['barry','alex']]
l2 = l1

l1[0] = 111
print(l1)  # [111, 2, 3, ['barry', 'alex']]
print(l2)  # [111, 2, 3, ['barry', 'alex']]

l1[3][0] = 'wusir'
print(l1)  # [111, 2, 3, ['wusir', 'alex']]
print(l2)  # [111, 2, 3, ['wusir', 'alex']]

'''
对于赋值运算来说，l1与l2指向的是同一个内存地址，所以他们是完全一样的，在举个例子，比如张三李四合租在一起，那么对于客厅来说，他们是公用的，张三可以用，李四也可以用，但是突然有一天张三把客厅的的电视换成投影了，那么李四使用客厅时，想看电视没有了，而是投影了，对吧？l1,l2指向的是同一个列表，任何一个变量对列表进行改变，剩下那个变量在使用列表之后，这个列表就是发生改变之后的列表。
'''

import copy
# 浅copy: 会在内存空间中新开辟一个空间，存放这个copy的列表，但是列表里面的内容还是沿用之前对象的内存地址，所以l3和l4的id不同，但是内容id相同
l3 = [1, '太白', True, (1, 2, 3), [22, 33]]
l4 = l3.copy()

print(id(l3), id(l4))                  # 4395753352  4395753288
print((id(l3[-2]), id(l4[-2])))        # (4395743632, 4395743632)

# 不同代码块下：

# >>> l1 = [1, '太白', True, (1, 2, 3), [22, 33]]
# >>> l2 = l1.copy()
# >>> print(id(l1), id(l2))
# 1477183162120 1477183162696
# >>> print(id(l1[-2]), id(l2[-2]))
# 1477181814032 1477181814032
# >>> print(id(l1[-1]), id(l2[-1]))
# 1477183162504 1477183162504

# 对于浅copy来说，只是在内存中重新创建了开辟了一个空间存放一个新列表，但是新列表中的元素与原列表中的元素是公用的。
#


# 深拷贝deepcopy：深copy特性就是将可变的数据类型在内存中重新复制一份，不可变的数据类型沿用之前的
l5 = [1, 'alex', True, (1,2,3), [22, 33]]
l6 = copy.deepcopy(l5)
print(id(l5), id(l6))
print(id(l5[0]), id(l6[0]))
print(id(l5[1]), id(l6[1]))
print(id(l5[-1]), id(l6[-1]))






l1 = [1, 2, 3, 4, ['alex']]
l2 = l1[::]
l1[-1].append(666)
print(l2)